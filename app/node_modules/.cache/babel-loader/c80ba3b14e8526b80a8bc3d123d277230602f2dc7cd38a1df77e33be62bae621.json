{"ast":null,"code":"const errors = require(\"./errors\");\n\n/** Provides validation and access methods for a WebHook.\n *\n * Before accessing WebHook data, check if it's valid. Otherwise, exceptions\n * will be raised from access methods.\n *\n * @constructor\n * @param {Token} primary token\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n */\nfunction WebHook(token, request) {\n  this.token = token;\n  this.key = request.headers[\"x-pusher-key\"];\n  this.signature = request.headers[\"x-pusher-signature\"];\n  this.contentType = request.headers[\"content-type\"];\n  this.body = request.rawBody;\n  if (this.isContentTypeValid()) {\n    try {\n      // Try to parse as JSON\n      this.data = JSON.parse(this.body);\n    } catch (e) {\n      // Do nothing\n    }\n  }\n}\n\n/** Checks whether the WebHook has valid body and signature.\n *\n * @param {Token|Token[]} list of additional tokens to be validated against\n * @returns {Boolean}\n */\nWebHook.prototype.isValid = function (extraTokens) {\n  if (!this.isBodyValid()) {\n    return false;\n  }\n  extraTokens = extraTokens || [];\n  if (!(extraTokens instanceof Array)) {\n    extraTokens = [extraTokens];\n  }\n  const tokens = [this.token].concat(extraTokens);\n  for (const i in tokens) {\n    const token = tokens[i];\n    if (this.key == token.key && token.verify(this.body, this.signature)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/** Checks whether the WebHook content type is valid.\n *\n * For now, the only valid WebHooks have content type of application/json.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isContentTypeValid = function () {\n  return this.contentType === \"application/json\";\n};\n\n/** Checks whether the WebHook content type and body is JSON.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isBodyValid = function () {\n  return this.data !== undefined;\n};\n\n/** Returns all WebHook data.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object}\n */\nWebHook.prototype.getData = function () {\n  if (!this.isBodyValid()) {\n    throw new errors.WebHookError(\"Invalid WebHook body\", this.contentType, this.body, this.signature);\n  }\n  return this.data;\n};\n\n/** Returns WebHook events array.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object[]}\n */\nWebHook.prototype.getEvents = function () {\n  return this.getData().events;\n};\n\n/** Returns WebHook timestamp.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Date}\n */\nWebHook.prototype.getTime = function () {\n  return new Date(this.getData().time_ms);\n};\nmodule.exports = WebHook;","map":{"version":3,"names":["errors","require","WebHook","token","request","key","headers","signature","contentType","body","rawBody","isContentTypeValid","data","JSON","parse","e","prototype","isValid","extraTokens","isBodyValid","Array","tokens","concat","i","verify","undefined","getData","WebHookError","getEvents","events","getTime","Date","time_ms","module","exports"],"sources":["/workspace/messaging-app/app/node_modules/pusher/lib/webhook.js"],"sourcesContent":["const errors = require(\"./errors\")\n\n/** Provides validation and access methods for a WebHook.\n *\n * Before accessing WebHook data, check if it's valid. Otherwise, exceptions\n * will be raised from access methods.\n *\n * @constructor\n * @param {Token} primary token\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n */\nfunction WebHook(token, request) {\n  this.token = token\n\n  this.key = request.headers[\"x-pusher-key\"]\n  this.signature = request.headers[\"x-pusher-signature\"]\n  this.contentType = request.headers[\"content-type\"]\n  this.body = request.rawBody\n\n  if (this.isContentTypeValid()) {\n    try {\n      // Try to parse as JSON\n      this.data = JSON.parse(this.body)\n    } catch (e) {\n      // Do nothing\n    }\n  }\n}\n\n/** Checks whether the WebHook has valid body and signature.\n *\n * @param {Token|Token[]} list of additional tokens to be validated against\n * @returns {Boolean}\n */\nWebHook.prototype.isValid = function (extraTokens) {\n  if (!this.isBodyValid()) {\n    return false\n  }\n\n  extraTokens = extraTokens || []\n  if (!(extraTokens instanceof Array)) {\n    extraTokens = [extraTokens]\n  }\n\n  const tokens = [this.token].concat(extraTokens)\n  for (const i in tokens) {\n    const token = tokens[i]\n    if (this.key == token.key && token.verify(this.body, this.signature)) {\n      return true\n    }\n  }\n  return false\n}\n\n/** Checks whether the WebHook content type is valid.\n *\n * For now, the only valid WebHooks have content type of application/json.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isContentTypeValid = function () {\n  return this.contentType === \"application/json\"\n}\n\n/** Checks whether the WebHook content type and body is JSON.\n *\n * @returns {Boolean}\n */\nWebHook.prototype.isBodyValid = function () {\n  return this.data !== undefined\n}\n\n/** Returns all WebHook data.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object}\n */\nWebHook.prototype.getData = function () {\n  if (!this.isBodyValid()) {\n    throw new errors.WebHookError(\n      \"Invalid WebHook body\",\n      this.contentType,\n      this.body,\n      this.signature\n    )\n  }\n  return this.data\n}\n\n/** Returns WebHook events array.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Object[]}\n */\nWebHook.prototype.getEvents = function () {\n  return this.getData().events\n}\n\n/** Returns WebHook timestamp.\n *\n * @throws WebHookError when WebHook is invalid\n * @returns {Date}\n */\nWebHook.prototype.getTime = function () {\n  return new Date(this.getData().time_ms)\n}\n\nmodule.exports = WebHook\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAO,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC/B,IAAI,CAACD,KAAK,GAAGA,KAAK;EAElB,IAAI,CAACE,GAAG,GAAGD,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC;EAC1C,IAAI,CAACC,SAAS,GAAGH,OAAO,CAACE,OAAO,CAAC,oBAAoB,CAAC;EACtD,IAAI,CAACE,WAAW,GAAGJ,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC;EAClD,IAAI,CAACG,IAAI,GAAGL,OAAO,CAACM,OAAO;EAE3B,IAAI,IAAI,CAACC,kBAAkB,EAAE,EAAE;IAC7B,IAAI;MACF;MACA,IAAI,CAACC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACL,IAAI,CAAC;IACnC,CAAC,CAAC,OAAOM,CAAC,EAAE;MACV;IAAA;EAEJ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACAb,OAAO,CAACc,SAAS,CAACC,OAAO,GAAG,UAAUC,WAAW,EAAE;EACjD,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE,EAAE;IACvB,OAAO,KAAK;EACd;EAEAD,WAAW,GAAGA,WAAW,IAAI,EAAE;EAC/B,IAAI,EAAEA,WAAW,YAAYE,KAAK,CAAC,EAAE;IACnCF,WAAW,GAAG,CAACA,WAAW,CAAC;EAC7B;EAEA,MAAMG,MAAM,GAAG,CAAC,IAAI,CAAClB,KAAK,CAAC,CAACmB,MAAM,CAACJ,WAAW,CAAC;EAC/C,KAAK,MAAMK,CAAC,IAAIF,MAAM,EAAE;IACtB,MAAMlB,KAAK,GAAGkB,MAAM,CAACE,CAAC,CAAC;IACvB,IAAI,IAAI,CAAClB,GAAG,IAAIF,KAAK,CAACE,GAAG,IAAIF,KAAK,CAACqB,MAAM,CAAC,IAAI,CAACf,IAAI,EAAE,IAAI,CAACF,SAAS,CAAC,EAAE;MACpE,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAL,OAAO,CAACc,SAAS,CAACL,kBAAkB,GAAG,YAAY;EACjD,OAAO,IAAI,CAACH,WAAW,KAAK,kBAAkB;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACAN,OAAO,CAACc,SAAS,CAACG,WAAW,GAAG,YAAY;EAC1C,OAAO,IAAI,CAACP,IAAI,KAAKa,SAAS;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAvB,OAAO,CAACc,SAAS,CAACU,OAAO,GAAG,YAAY;EACtC,IAAI,CAAC,IAAI,CAACP,WAAW,EAAE,EAAE;IACvB,MAAM,IAAInB,MAAM,CAAC2B,YAAY,CAC3B,sBAAsB,EACtB,IAAI,CAACnB,WAAW,EAChB,IAAI,CAACC,IAAI,EACT,IAAI,CAACF,SAAS,CACf;EACH;EACA,OAAO,IAAI,CAACK,IAAI;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAV,OAAO,CAACc,SAAS,CAACY,SAAS,GAAG,YAAY;EACxC,OAAO,IAAI,CAACF,OAAO,EAAE,CAACG,MAAM;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA3B,OAAO,CAACc,SAAS,CAACc,OAAO,GAAG,YAAY;EACtC,OAAO,IAAIC,IAAI,CAAC,IAAI,CAACL,OAAO,EAAE,CAACM,OAAO,CAAC;AACzC,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAGhC,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}