{"ast":null,"code":"const crypto = require(\"crypto\");\nconst url = require(\"url\");\nconst auth = require(\"./auth\");\nconst errors = require(\"./errors\");\nconst events = require(\"./events\");\nconst requests = require(\"./requests\");\nconst PusherConfig = require(\"./pusher_config\");\nconst Token = require(\"./token\");\nconst WebHook = require(\"./webhook\");\nconst NotificationClient = require(\"./notification_client\");\nconst validateChannel = function (channel) {\n  if (typeof channel !== \"string\" || channel === \"\" || channel.match(/[^A-Za-z0-9_\\-=@,.;]/)) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\");\n  }\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\");\n  }\n};\nconst validateSocketId = function (socketId) {\n  if (typeof socketId !== \"string\" || socketId === \"\" || !socketId.match(/^\\d+\\.\\d+$/)) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\");\n  }\n};\nconst validateUserId = function (userId) {\n  if (typeof userId !== \"string\" || userId === \"\") {\n    throw new Error(\"Invalid user id: '\" + userId + \"'\");\n  }\n};\nconst validateUserData = function (userData) {\n  if (userData == null || typeof userData !== \"object\") {\n    throw new Error(\"Invalid user data: '\" + userData + \"'\");\n  }\n  validateUserId(userData.id);\n};\n\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Agent} [options.agent] http agent to use\n */\nfunction Pusher(options) {\n  this.config = new PusherConfig(options);\n  const notificationOptions = Object.assign({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted\n  });\n  this.notificationClient = new NotificationClient(notificationOptions);\n}\n\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\nPusher.forURL = function (pusherUrl, options) {\n  const apiUrl = url.parse(pusherUrl);\n  const apiPath = apiUrl.pathname.split(\"/\");\n  const apiAuth = apiUrl.auth.split(\":\");\n  return new Pusher(Object.assign({}, options || {}, {\n    scheme: apiUrl.protocol.replace(/:$/, \"\"),\n    host: apiUrl.hostname,\n    port: parseInt(apiUrl.port, 10) || undefined,\n    appId: parseInt(apiPath[apiPath.length - 1], 10),\n    key: apiAuth[0],\n    secret: apiAuth[1]\n  }));\n};\n\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\nPusher.forCluster = function (cluster, options) {\n  return new Pusher(Object.assign({}, options || {}, {\n    host: \"api-\" + cluster + \".pusher.com\"\n  }));\n};\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authorizeChannel = function (socketId, channel, data) {\n  validateSocketId(socketId);\n  validateChannel(channel);\n  return auth.getSocketSignature(this, this.config.token, channel, socketId, data);\n};\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n *  DEPRECATED. Use authorizeChannel.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authenticate = Pusher.prototype.authorizeChannel;\n\n/** Returns a signature for given socket id and user data.\n *\n * @param {String} socketId socket id\n * @param {Object} userData user data\n * @returns {String} authentication signature\n */\nPusher.prototype.authenticateUser = function (socketId, userData) {\n  validateSocketId(socketId);\n  validateUserData(userData);\n  return auth.getSocketSignatureForUser(this.config.token, socketId, userData);\n};\n\n/** Sends an event to a user.\n *\n * Event name can be at most 200 characters long.\n *\n * @param {String} userId user id\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.sendToUser = function (userId, event, data) {\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n  validateUserId(userId);\n  return events.trigger(this, [`#server-to-user-${userId}`], event, data);\n};\n\n/** Terminate users's connections.\n *\n *\n * @param {String} userId user id\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.terminateUserConnections = function (userId) {\n  validateUserId(userId);\n  return this.post({\n    path: `/users/${userId}/terminate_connections`,\n    body: {}\n  });\n};\n\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {Object} [params] additional optional request body parameters\n * @param {String} [params.socket_id] id of a socket that should not receive the event\n * @param {String} [params.info] a comma separate list of attributes to be returned in the response. Experimental, see https://pusher.com/docs/lab#experimental-program\n * @see RequestError\n */\nPusher.prototype.trigger = function (channels, event, data, params) {\n  if (params && params.socket_id) {\n    validateSocketId(params.socket_id);\n  }\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels];\n  }\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\");\n  }\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\");\n  }\n  for (let i = 0; i < channels.length; i++) {\n    validateChannel(channels[i]);\n  }\n  return events.trigger(this, channels, event, data, params);\n};\n\n/* Triggers a batch of events\n *\n * @param {Event[]} An array of events, where Event is\n * {\n *   name: string,\n *   channel: string,\n *   data: any JSON-encodable data,\n *   socket_id: [optional] string,\n *   info: [optional] string experimental, see https://pusher.com/docs/lab#experimental-program\n * }\n */\nPusher.prototype.triggerBatch = function (batch) {\n  return events.triggerBatch(this, batch);\n};\nPusher.prototype.notify = function () {\n  this.notificationClient.notify.apply(this.notificationClient, arguments);\n};\n\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @see RequestError\n */\nPusher.prototype.post = function (options) {\n  return requests.send(this.config, Object.assign({}, options, {\n    method: \"POST\"\n  }));\n};\n\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @see RequestError\n */\nPusher.prototype.get = function (options) {\n  return requests.send(this.config, Object.assign({}, options, {\n    method: \"GET\"\n  }));\n};\n\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\nPusher.prototype.webhook = function (request) {\n  return new WebHook(this.config.token, request);\n};\n\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\nPusher.prototype.createSignedQueryString = function (options) {\n  return requests.createSignedQueryString(this.config.token, options);\n};\nPusher.prototype.channelSharedSecret = function (channel) {\n  return crypto.createHash(\"sha256\").update(Buffer.concat([Buffer.from(channel), this.config.encryptionMasterKey])).digest();\n};\n\n/** Exported {@link Token} constructor. */\nPusher.Token = Token;\n/** Exported {@link RequestError} constructor. */\nPusher.RequestError = errors.RequestError;\n/** Exported {@link WebHookError} constructor. */\nPusher.WebHookError = errors.WebHookError;\nmodule.exports = Pusher;","map":{"version":3,"names":["crypto","require","url","auth","errors","events","requests","PusherConfig","Token","WebHook","NotificationClient","validateChannel","channel","match","Error","length","validateSocketId","socketId","validateUserId","userId","validateUserData","userData","id","Pusher","options","config","notificationOptions","Object","assign","host","notificationHost","encrypted","notificationEncrypted","notificationClient","forURL","pusherUrl","apiUrl","parse","apiPath","pathname","split","apiAuth","scheme","protocol","replace","hostname","port","parseInt","undefined","appId","key","secret","forCluster","cluster","prototype","authorizeChannel","data","getSocketSignature","token","authenticate","authenticateUser","getSocketSignatureForUser","sendToUser","event","trigger","terminateUserConnections","post","path","body","channels","params","socket_id","Array","i","triggerBatch","batch","notify","apply","arguments","send","method","get","webhook","request","createSignedQueryString","channelSharedSecret","createHash","update","Buffer","concat","from","encryptionMasterKey","digest","RequestError","WebHookError","module","exports"],"sources":["/workspace/messaging-app/app/node_modules/pusher/lib/pusher.js"],"sourcesContent":["const crypto = require(\"crypto\")\nconst url = require(\"url\")\n\nconst auth = require(\"./auth\")\nconst errors = require(\"./errors\")\nconst events = require(\"./events\")\nconst requests = require(\"./requests\")\n\nconst PusherConfig = require(\"./pusher_config\")\nconst Token = require(\"./token\")\nconst WebHook = require(\"./webhook\")\nconst NotificationClient = require(\"./notification_client\")\n\nconst validateChannel = function (channel) {\n  if (\n    typeof channel !== \"string\" ||\n    channel === \"\" ||\n    channel.match(/[^A-Za-z0-9_\\-=@,.;]/)\n  ) {\n    throw new Error(\"Invalid channel name: '\" + channel + \"'\")\n  }\n  if (channel.length > 200) {\n    throw new Error(\"Channel name too long: '\" + channel + \"'\")\n  }\n}\n\nconst validateSocketId = function (socketId) {\n  if (\n    typeof socketId !== \"string\" ||\n    socketId === \"\" ||\n    !socketId.match(/^\\d+\\.\\d+$/)\n  ) {\n    throw new Error(\"Invalid socket id: '\" + socketId + \"'\")\n  }\n}\n\nconst validateUserId = function (userId) {\n  if (typeof userId !== \"string\" || userId === \"\") {\n    throw new Error(\"Invalid user id: '\" + userId + \"'\")\n  }\n}\n\nconst validateUserData = function (userData) {\n  if (userData == null || typeof userData !== \"object\") {\n    throw new Error(\"Invalid user data: '\" + userData + \"'\")\n  }\n  validateUserId(userData.id)\n}\n\n/** Provides access to Pusher's REST API, WebHooks and authentication.\n *\n * @constructor\n * @param {Object} options\n * @param {String} [options.host=\"api.pusherapp.com\"] API hostname\n * @param {String} [options.notification_host=\"api.pusherapp.com\"] Notification API hostname\n * @param {Boolean} [options.useTLS=false] whether to use TLS\n * @param {Boolean} [options.encrypted=false] deprecated; renamed to `useTLS`\n * @param {Boolean} [options.notification_encrypted=false] whether to use TLS for notifications\n * @param {Integer} [options.port] port, default depends on the scheme\n * @param {Integer} options.appId application ID\n * @param {String} options.key application key\n * @param {String} options.secret application secret\n * @param {Integer} [options.timeout] request timeout in milliseconds\n * @param {Agent} [options.agent] http agent to use\n */\nfunction Pusher(options) {\n  this.config = new PusherConfig(options)\n  const notificationOptions = Object.assign({}, options, {\n    host: options.notificationHost,\n    encrypted: options.notificationEncrypted,\n  })\n  this.notificationClient = new NotificationClient(notificationOptions)\n}\n\n/** Create a Pusher instance using a URL.\n *\n * URL should be in SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID form.\n *\n * @param {String} pusherUrl URL containing endpoint and app details\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the URL and options\n */\nPusher.forURL = function (pusherUrl, options) {\n  const apiUrl = url.parse(pusherUrl)\n  const apiPath = apiUrl.pathname.split(\"/\")\n  const apiAuth = apiUrl.auth.split(\":\")\n\n  return new Pusher(\n    Object.assign({}, options || {}, {\n      scheme: apiUrl.protocol.replace(/:$/, \"\"),\n      host: apiUrl.hostname,\n      port: parseInt(apiUrl.port, 10) || undefined,\n      appId: parseInt(apiPath[apiPath.length - 1], 10),\n      key: apiAuth[0],\n      secret: apiAuth[1],\n    })\n  )\n}\n\n/** Create a Pusher instance using a cluster name.\n *\n * @param {String} cluster cluster name\n * @param {Object} [options] options, see the {@link Pusher} for details\n * @returns {Pusher} instance configured for the cluster and options\n */\nPusher.forCluster = function (cluster, options) {\n  return new Pusher(\n    Object.assign({}, options || {}, {\n      host: \"api-\" + cluster + \".pusher.com\",\n    })\n  )\n}\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authorizeChannel = function (socketId, channel, data) {\n  validateSocketId(socketId)\n  validateChannel(channel)\n\n  return auth.getSocketSignature(\n    this,\n    this.config.token,\n    channel,\n    socketId,\n    data\n  )\n}\n\n/** Returns a signature for given socket id, channel and socket data.\n *\n *  DEPRECATED. Use authorizeChannel.\n *\n * @param {String} socketId socket id\n * @param {String} channel channel name\n * @param {Object} [data] additional socket data\n * @returns {String} authorization signature\n */\nPusher.prototype.authenticate = Pusher.prototype.authorizeChannel\n\n/** Returns a signature for given socket id and user data.\n *\n * @param {String} socketId socket id\n * @param {Object} userData user data\n * @returns {String} authentication signature\n */\nPusher.prototype.authenticateUser = function (socketId, userData) {\n  validateSocketId(socketId)\n  validateUserData(userData)\n\n  return auth.getSocketSignatureForUser(this.config.token, socketId, userData)\n}\n\n/** Sends an event to a user.\n *\n * Event name can be at most 200 characters long.\n *\n * @param {String} userId user id\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.sendToUser = function (userId, event, data) {\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\")\n  }\n  validateUserId(userId)\n  return events.trigger(this, [`#server-to-user-${userId}`], event, data)\n}\n\n/** Terminate users's connections.\n *\n *\n * @param {String} userId user id\n * @returns {Promise} a promise resolving to a response, or rejecting to a RequestError.\n * @see RequestError\n */\nPusher.prototype.terminateUserConnections = function (userId) {\n  validateUserId(userId)\n  return this.post({ path: `/users/${userId}/terminate_connections`, body: {} })\n}\n\n/** Triggers an event.\n *\n * Channel names can contain only characters which are alphanumeric, '_' or '-'\n * and have to be at most 200 characters long.\n *\n * Event name can be at most 200 characters long.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {String|String[]} channel list of at most 100 channels\n * @param {String} event event name\n * @param data event data, objects are JSON-encoded\n * @param {Object} [params] additional optional request body parameters\n * @param {String} [params.socket_id] id of a socket that should not receive the event\n * @param {String} [params.info] a comma separate list of attributes to be returned in the response. Experimental, see https://pusher.com/docs/lab#experimental-program\n * @see RequestError\n */\nPusher.prototype.trigger = function (channels, event, data, params) {\n  if (params && params.socket_id) {\n    validateSocketId(params.socket_id)\n  }\n  if (!(channels instanceof Array)) {\n    // add single channel to array for multi trigger compatibility\n    channels = [channels]\n  }\n  if (event.length > 200) {\n    throw new Error(\"Too long event name: '\" + event + \"'\")\n  }\n  if (channels.length > 100) {\n    throw new Error(\"Can't trigger a message to more than 100 channels\")\n  }\n  for (let i = 0; i < channels.length; i++) {\n    validateChannel(channels[i])\n  }\n  return events.trigger(this, channels, event, data, params)\n}\n\n/* Triggers a batch of events\n *\n * @param {Event[]} An array of events, where Event is\n * {\n *   name: string,\n *   channel: string,\n *   data: any JSON-encodable data,\n *   socket_id: [optional] string,\n *   info: [optional] string experimental, see https://pusher.com/docs/lab#experimental-program\n * }\n */\nPusher.prototype.triggerBatch = function (batch) {\n  return events.triggerBatch(this, batch)\n}\n\nPusher.prototype.notify = function () {\n  this.notificationClient.notify.apply(this.notificationClient, arguments)\n}\n\n/** Makes a POST request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @see RequestError\n */\nPusher.prototype.post = function (options) {\n  return requests.send(\n    this.config,\n    Object.assign({}, options, { method: \"POST\" })\n  )\n}\n\n/** Makes a GET request to Pusher, handles the authentication.\n *\n * Returns a promise resolving to a response, or rejecting to a RequestError.\n *\n * @param {Object} options\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @see RequestError\n */\nPusher.prototype.get = function (options) {\n  return requests.send(\n    this.config,\n    Object.assign({}, options, { method: \"GET\" })\n  )\n}\n\n/** Creates a WebHook object for a given request.\n *\n * @param {Object} request\n * @param {Object} request.headers WebHook HTTP headers with lower-case keys\n * @param {String} request.rawBody raw WebHook body\n * @returns {WebHook}\n */\nPusher.prototype.webhook = function (request) {\n  return new WebHook(this.config.token, request)\n}\n\n/** Builds a signed query string that can be used in a request to Pusher.\n *\n * @param {Object} options\n * @param {String} options.method request method\n * @param {String} options.path request path\n * @param {Object} options.params query params\n * @param {String} options.body request body\n * @returns {String} signed query string\n */\nPusher.prototype.createSignedQueryString = function (options) {\n  return requests.createSignedQueryString(this.config.token, options)\n}\n\nPusher.prototype.channelSharedSecret = function (channel) {\n  return crypto\n    .createHash(\"sha256\")\n    .update(\n      Buffer.concat([Buffer.from(channel), this.config.encryptionMasterKey])\n    )\n    .digest()\n}\n\n/** Exported {@link Token} constructor. */\nPusher.Token = Token\n/** Exported {@link RequestError} constructor. */\nPusher.RequestError = errors.RequestError\n/** Exported {@link WebHookError} constructor. */\nPusher.WebHookError = errors.WebHookError\n\nmodule.exports = Pusher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}